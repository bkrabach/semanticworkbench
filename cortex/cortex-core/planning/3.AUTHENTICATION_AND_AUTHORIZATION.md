# Authentication & Authorization (Auth0 Integration) Implementation Guide

## Overview

This guide outlines how to implement the **Authentication & Authorization** layer for the Cortex Core MVP, focusing on integrating Auth0 for JWT-based authentication. The approach strictly follows Cortex's implementation philosophy of **ruthless simplicity** and **direct library usage**. We will avoid premature abstractions and keep concerns isolated. The result will be a clean, minimal solution: verifying Auth0-issued JWTs in production, while providing a simplified fallback for local development.

**Key objectives:**

- **Production-grade JWT verification (Auth0)** using RS256 and Auth0's JWKS (JSON Web Key Set).
- **Development-mode fallback** using a simple HS256-signed token and stub login, for convenience when Auth0 integration is not available.
- **Minimal interface**: a single FastAPI dependency function to authenticate requests (`get_current_user`), and a lightweight helper for JWT validation.
- **No unnecessary layers**: Use libraries like `python-jose` (PyJWT) or Authlib directly for decoding and verifying JWTs. No additional wrappers or complex services.
- **Clear separation**: The production and development flows are toggled via a configuration flag, ensuring no mix of concerns and easy testing in both modes.

By the end, you'll have a couple of example endpoints (`/auth/login` and `/auth/verify`) to test the authentication flow, and an understanding of how to extend or adapt this setup.

## Production vs Development Modes

**Production mode (Auth0 integration):** In a deployed environment, Cortex Core will rely on Auth0 to handle user authentication and issue JWTs. These JWTs are signed with Auth0's private key using the RS256 algorithm. Our server must **verify the token's signature** using Auth0's public keys. Auth0 exposes its public keys via a JWKS endpoint (e.g., `https://<your-auth0-domain>/.well-known/jwks.json`). The server will fetch the appropriate key from this set and use it to verify the JWT. This ensures that only tokens issued by your Auth0 tenant (and intended for your API) are accepted. We will also validate critical token claims like expiration time (`exp`), the issuer (`iss`), and audience (`aud`) to enforce that the token is fresh, from the correct Auth0 domain, and meant for our API.

**Development mode (local stub):** During local development or testing without access to Auth0, we provide a simplified alternative. Instead of RS256, the server will accept JWTs signed with a **shared secret** using HS256 (HMAC SHA256). We will create a dummy login endpoint that issues such tokens for testing. This way, developers can simulate authentication locally without needing the Auth0 infrastructure. This stub is clearly marked and used **only in development** – in production it will be disabled. The shared secret is defined locally (e.g., via an environment variable or config file) and should never be the same as any production secret. The HS256 token will carry the same types of claims (user ID, email, etc.) but is signed and verified symmetrically with the known secret.

**Toggling modes:** A configuration flag or environment variable (for example, `USE_AUTH0` or `ENV=production/development`) will control which mode the authentication system runs in. In production, the flag should ensure only the Auth0 verification is active and the dev login is turned off. In development, the flag enables the stub login and uses the local secret for token verification. This toggle prevents mixing the two modes and allows easy switching without code changes. We will demonstrate using a simple environment variable to decide the mode.

By clearly separating the Auth0 flow and the dev fallback, we maintain **isolation of concerns**. The production path deals only with public key verification and Auth0-specific details, whereas the dev path is self-contained and does not impact production security.

## JWT Validation Implementation

### Using Direct JWT Libraries

In line with our philosophy of direct integration, we will use a JWT library directly (such as `python-jose`/PyJWT or Authlib) to handle token decoding and verification. This avoids custom parsing of JWTs or using high-level wrappers that might obscure the process. The chosen library should be capable of:

- Decoding a JWT and verifying its signature with a given key.
- Handling RS256 (asymmetric) verification by providing the public key.
- Handling HS256 (symmetric) verification with a secret.
- Raising errors if the token is invalid or expired.

**Library choice:** Both [PyJWT](https://pyjwt.readthedocs.io/) (often used via `python-jose` or directly as `jwt` package) and [Authlib](https://docs.authlib.org/) can accomplish this. In this guide, we’ll illustrate using PyJWT (part of `python-jose`) for clarity, but you could adapt the code to Authlib easily. PyJWT offers a utility called `PyJWKClient` that will help fetch and parse JWKS keys from Auth0.

Make sure to install the library (and cryptography, which PyJWT uses for RSA) in your project, for example:

```bash
pip install pyjwt cryptography
```

_(If you choose Authlib, install it accordingly.)_

### Auth0 JWT Verification (RS256 with JWKS)

In production mode, the core of JWT validation involves retrieving the signing key from Auth0 and verifying the token's signature. Here's how to implement it:

1. **Configuration**: Define your Auth0 domain and API audience in your settings (these are provided when you set up an Auth0 API). For example:

   ```python
   AUTH0_DOMAIN = "your-tenant.auth0.com"
   AUTH0_AUDIENCE = "https://your-api-audience"
   ```

   Also define the expected issuer URI (usually `https://<your-tenant>.auth0.com/`).

2. **JWKS Client Setup**: Initialize a JWKS client using the Auth0 domain. PyJWT's `PyJWKClient` can be pointed to Auth0's JWKS URL:

   ```python
   from jwt import PyJWKClient

   jwks_url = f"https://{AUTH0_DOMAIN}/.well-known/jwks.json"
   jwks_client = PyJWKClient(jwks_url)
   ```

   This client will allow us to get the appropriate public key for a given token.

3. **Token Verification Process**:

   - Extract the JWT from the incoming request (usually from the `Authorization` header). We'll cover this in the next section with the FastAPI dependency.
   - Use the JWKS client to retrieve the signing key:
     ```python
     signing_key = jwks_client.get_signing_key_from_jwt(token).key
     ```
     This finds the public key in Auth0's JWKS that matches the token's `kid` (key ID) header. The result's `.key` is a cryptography PublicKey object.
   - Decode and verify the JWT:
     ```python
     import jwt  # PyJWT
     payload = jwt.decode(
         token,
         signing_key,
         algorithms=["RS256"],
         audience=AUTH0_AUDIENCE,
         issuer=f"https://{AUTH0_DOMAIN}/"
     )
     ```
     This will:
     - Verify the token’s signature against the provided `signing_key`.
     - Ensure the token’s `alg` is RS256 (since we specify algorithms).
     - Check the `aud` claim matches our `AUTH0_AUDIENCE`.
     - Check the `iss` claim matches our Auth0 domain URL.
     - Check the token is not expired (`exp` claim) and is not used before its `nbf` (not-before) time.
       If any of these checks fail or the token is malformed, `jwt.decode` will raise an exception (such as `jwt.ExpiredSignatureError`, `jwt.InvalidTokenError`, etc.).

4. **Extract User Claims**: If decoding is successful, we get a `payload` dictionary of the JWT claims. From this, we can pull the standard user information that Auth0 tokens usually include:
   - `sub`: the subject identifier for the user (often the Auth0 user ID).
   - `email`: the user's email address (if included in the token’s scope/claims).
   - `name`: the user's name (if included).
     Other claims like `iat` (issued-at time), `exp` (expiry), and any custom claims are also available if needed. For our purposes, we will map `sub`, `email`, and `name` into our internal user representation.

This direct use of PyJWT ensures a **production-compatible flow** with minimal code. We leverage Auth0's JWKS endpoint and PyJWT's built-in validation – no custom cryptography or manual JWT parsing is needed.

### Development JWT Verification (HS256 with Local Secret)

For development mode, the process is simpler since we use a symmetric key:

1. **Define a Secret**: Set a development secret key in configuration (e.g., `DEV_SECRET = "super-secret-dev-key"`). This should be a secure random string, but since it's only for dev and testing, it can be hard-coded or loaded from an env var. **Never use this secret in production.**

2. **Token Decoding**: When a token is received in dev mode, decode it using the secret:

   ```python
   payload = jwt.decode(token, DEV_SECRET, algorithms=["HS256"])
   ```

   This will verify the HMAC signature using the shared secret and check expiry (`exp`) if present. In dev mode, we might not have an `aud` or `iss` to verify (unless we choose to set them), so this is usually enough. If you do include `aud` or other claims in the dev tokens, you can provide options or expected values similarly to the production case.

3. **Extract Claims**: Similar to above, extract `sub`, `email`, `name` from the decoded payload to represent the user.

Because the same secret is used for signing and verifying, there's no need for JWKS retrieval. This makes the dev flow self-contained. We intentionally keep the dev verification logic separate from the production logic for clarity, even if they both use the same `jwt.decode` function under the hood.

### Auth0JWTVerifier Helper

To encapsulate the production JWT verification logic, it's useful to have a small helper class or function. This prevents repeating JWKS fetching and decode logic in multiple places, and isolates Auth0-specific details.

For example, an `Auth0JWTVerifier` class:

```python
class Auth0JWTVerifier:
    def __init__(self, domain: str, audience: str):
        self.domain = domain
        self.audience = audience
        self.issuer = f"https://{domain}/"
        jwks_url = f"https://{domain}/.well-known/jwks.json"
        self.jwks_client = PyJWKClient(jwks_url)

    def verify(self, token: str) -> dict:
        # Get the public key for this token
        signing_key = self.jwks_client.get_signing_key_from_jwt(token).key
        # Decode and verify the token
        payload = jwt.decode(
            token,
            signing_key,
            algorithms=["RS256"],
            audience=self.audience,
            issuer=self.issuer
        )
        return payload
```

This class can be initialized at application startup with the known domain and audience, and then reused to verify any incoming token. The `verify` method returns the payload (claims) if the token is valid, or raises an exception if not. Internally it uses direct PyJWT calls as described. This is a thin helper – not a large abstraction – which simply streamlines the JWKS key caching and jwt decoding.

In development mode, such a class isn’t strictly necessary, since verification is one line. But for symmetry, you could create a similar helper for HS256, or even incorporate both modes into one class that switches based on mode. However, keeping them separate or using simple `if` logic is often clearer and aligns with our minimalist approach.

By using these helpers or straightforward functions, we avoid any "magic" or hidden complexity. The code remains transparent: one can see we're either fetching keys and decoding, or just decoding with a secret.

## FastAPI Dependency: `get_current_user`

FastAPI allows us to define dependencies that run before endpoint logic to perform common tasks, such as authentication. We will create a dependency called `get_current_user` that checks the request for a valid JWT and returns the authenticated user information. If authentication fails, it will raise an error to prevent access.

Key responsibilities of `get_current_user`:

- Read the `Authorization` header from the HTTP request.
- Parse the header to extract the token (expecting the format "Bearer \<token\>").
- Decide which verification method to use (Auth0 vs local) based on the mode.
- Perform the verification (using the logic from the previous section).
- On success, return a user object (or dict) with the relevant identity info.
- On failure, raise an `HTTPException` with status 401 (Unauthorized).

Here's how you can implement it:

```python
from fastapi import Depends, Header, HTTPException
import jwt  # PyJWT from python-jose or PyJWT package

# Configuration flags and secrets
USE_AUTH0 = True  # or derive from env, e.g., bool(int(os.getenv("USE_AUTH0", "1")))
AUTH0_DOMAIN = "your-tenant.auth0.com"
AUTH0_AUDIENCE = "https://your-api-audience"
DEV_SECRET = "super-secret-dev-key"

# If using Auth0 mode, prepare JWKS client and verifier
if USE_AUTH0:
    jwks_client = PyJWKClient(f"https://{AUTH0_DOMAIN}/.well-known/jwks.json")

def get_current_user(authorization: str = Header(...)) -> dict:
    # 1. Check header presence and format
    if not authorization:
        raise HTTPException(status_code=401, detail="Authorization header missing")
    parts = authorization.split()
    if parts[0].lower() != "bearer" or len(parts) != 2:
        raise HTTPException(status_code=401, detail="Invalid Authorization header format")
    token = parts[1]

    try:
        if USE_AUTH0:
            # Production verification
            signing_key = jwks_client.get_signing_key_from_jwt(token).key
            payload = jwt.decode(
                token,
                signing_key,
                algorithms=["RS256"],
                audience=AUTH0_AUDIENCE,
                issuer=f"https://{AUTH0_DOMAIN}/"
            )
        else:
            # Development verification
            payload = jwt.decode(token, DEV_SECRET, algorithms=["HS256"])
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token has expired")
    except Exception as e:
        # catch-all for any other token error (invalid signature, wrong audience, etc.)
        raise HTTPException(status_code=401, detail="Invalid token: " + str(e))

    # 3. Extract user information from payload
    user = {
        "id": payload.get("sub"),
        "email": payload.get("email"),
        "name": payload.get("name")
    }
    if user["id"] is None:
        # sub is essential for identifying the user
        raise HTTPException(status_code=401, detail="Token payload missing 'sub' claim")
    return user
```

A few notes about this implementation:

- We directly use the `Header` parameter to get the Authorization header. FastAPI will pass the header string to our function.
- We perform basic validation on the format (must start with "Bearer").
- The `USE_AUTH0` flag (which you would set from an environment variable or config) switches the logic. In Auth0 mode, we use the JWKS client and verify with RS256; in dev mode, we use the shared secret with HS256.
- On any error during decoding, we raise `HTTPException(401)`. FastAPI will catch this and return a JSON response with status 401. The error message is kept generic or includes the exception message; in production, you might not want to expose internal errors, but for MVP this is fine or can be adjusted.
- We ensure the `sub` claim exists in the token; if not, the token isn't providing an identity, so we reject it.
- The returned `user` is a simple dict containing the user's ID, email, and name. This could just as easily be an instance of a Pydantic model (e.g., a `User` model defined in your domain models). For example, if you have `User` Pydantic class, you could do `user = User(id=..., email=..., name=...)` instead. Keeping it as a dict is sufficient for demonstration and can be integrated with the rest of the system as needed.

Using this dependency function in FastAPI is straightforward: include it as a dependency in any protected endpoint. For example:

```python
from fastapi import APIRouter, Depends

router = APIRouter()

@router.get("/protected-resource")
def read_protected(current_user: dict = Depends(get_current_user)):
    return {"message": f"Hello, {current_user['name']}!", "user": current_user}
```

Any request to `/protected-resource` will first go through `get_current_user`. If the token is valid, the endpoint function will receive the `current_user` info; if not, the request is aborted with a 401 error automatically.

This design ensures **no hidden global state** is needed for authentication. Every request carries its token, which is validated on the fly. The `get_current_user` function does rely on config constants (`USE_AUTH0`, secrets, etc.), but those are explicit and could also be provided via dependency injection (for example, using FastAPI's `Depends()` to bring in a Settings object). For simplicity, we used module-level constants, but they are read-only flags and secrets, which is acceptable for a minimal implementation.

## Example Auth Endpoints for Testing

To facilitate testing our authentication setup, especially in development mode, we'll implement two endpoints under an `/auth` route:

1. `POST /auth/login` – **Development Only.** In a real deployment with Auth0, users would obtain JWTs via Auth0's hosted login or other OAuth flows, not directly from our API. But for local testing, this endpoint acts as a dummy login: it accepts some credentials and returns a JWT signed with our dev secret. This allows quick testing of protected endpoints without setting up Auth0. We will disable or hide this endpoint when `USE_AUTH0` is True.

2. `GET /auth/verify` – **Protected Endpoint.** This endpoint requires a valid JWT (protected by `get_current_user`) and simply returns the current user information. It's useful to verify that authentication is working — the client must call it with a token and if everything is correct, they'll get their user identity back.

Here's how you could implement these:

```python
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from datetime import datetime, timedelta
import jwt

app = FastAPI()

# Pydantic model for login request (for clarity and validation)
class LoginRequest(BaseModel):
    username: str
    password: str

@app.post("/auth/login")
def dev_login(request: LoginRequest):
    if USE_AUTH0:
        # If running in Auth0 mode, this endpoint shouldn't be used
        raise HTTPException(status_code=404, detail="Not found")
    # In dev mode, accept a dummy username/password (or any, depending on your testing needs)
    # Here we check against a hardcoded dummy user for demonstration:
    if request.username != "testuser" or request.password != "testpass":
        raise HTTPException(status_code=401, detail="Invalid credentials")
    # Create a token for this dummy user
    now = datetime.utcnow()
    payload = {
        "sub": "dev|testuser",            # subject: unique user id (tagged with "dev|" to indicate it's from dev)
        "name": "Test User",              # name claim
        "email": "testuser@example.com",  # email claim
        "iat": now,
        "exp": now + timedelta(hours=1)   # token expires in 1 hour
    }
    token = jwt.encode(payload, DEV_SECRET, algorithm="HS256")
    return {"access_token": token, "token_type": "bearer"}

@app.get("/auth/verify")
def verify_token(current_user: dict = Depends(get_current_user)):
    # If we reached here, current_user is valid
    return {"authenticated_user": current_user}
```

A few notes on the above:

- We define a `LoginRequest` Pydantic model for the login payload (username and password). This is optional but provides clear structure and automatic validation.
- In `/auth/login`, we first check `USE_AUTH0`. If true, we return 404 to indicate this endpoint is not available (since in production you wouldn't expose a dummy login).
- We then check the provided credentials. In this example, we only authenticate a single fixed user (`testuser/testpass`). In practice, you could accept any username for testing and just reflect it in the token, or maintain a small list of test users. The key is to **keep it simple** – avoid any heavy database lookups or complex logic, since this is just a stub.
- If credentials match, we create a JWT. We include standard claims: `sub`, `name`, `email`, `iat` (issued at), and `exp` (expiration time). The `sub` is prefixed with `"dev|"` just to illustrate that it came from dev (this isn't necessary, but can prevent collision if your Auth0 `sub` format is different).
- We sign the token with `DEV_SECRET` using HS256 and return it in a JSON response.
- The `/auth/verify` endpoint uses `Depends(get_current_user)`, so it will require a valid token. If the token is valid, the dependency returns a user dict which we then return to the client. This simply echoes the authenticated user's info.

By trying out these endpoints, you can simulate the full flow:

- In dev mode, you can POST to `/auth/login` with the dummy credentials, get a token, then call `/auth/verify` with `Authorization: Bearer <token>` header and see that you are authenticated.
- In production mode (Auth0), you won't use `/auth/login`. Instead, you'd obtain a JWT by authenticating through Auth0 (for example, using Auth0's OAuth flow or their API explorer). Then you call `/auth/verify` with the Auth0-issued token in the header. The endpoint should return your Auth0 user details if the token is valid, or 401 if not.

These endpoints are primarily for testing and demonstrating the authentication mechanism. In a real application, you might not include an `/auth/verify` endpoint (since clients already know their identity once they have a token), and the login would be handled by Auth0's hosted pages or a dedicated auth service. But having them in the MVP helps during development and QA.

## Configuration and Environment Toggle

It's important to manage the mode (Auth0 vs dev) without changing code. Using an environment variable or a config setting is the recommended approach. For example, you could use a variable `CORTEX_ENV` which could be `"development"` or `"production"`, or a boolean like `AUTH0_ENABLED`.

A simple pattern is:

```python
import os
USE_AUTH0 = os.getenv("USE_AUTH0", "false").lower() == "true"
```

This would treat any truthy value of `USE_AUTH0` as enabling Auth0 mode. Alternatively, use a more descriptive `ENV`:

```python
ENV = os.getenv("ENV", "development")
USE_AUTH0 = ENV.lower() == "production"
```

In either case, the idea is to avoid hard-coding `USE_AUTH0 = True/False` in the code for each deployment. Instead, tie it to your deployment environment. During local dev, set the env variable to indicate dev mode. In your cloud/production, set it for production mode.

**Injecting config**: If you have a centralized configuration (using Pydantic's BaseSettings or similar), you can inject that into your endpoints or the dependency via `Depends()`. For example, a `Settings` object could hold `use_auth0`, `auth0_domain`, etc. You would then do `settings: Settings = Depends(get_settings)` in `get_current_user`. However, this adds a bit of complexity. Given our focus on minimalism, using module-level constants set at startup (from env) is acceptable and straightforward. The key is that these are only read, not modified at runtime, so the behavior is predictable and there is no hidden state changing underneath.

**No hidden global state**: All state that affects authentication (like the secret key or the JWKS client) is either constant or local to the authentication logic. We avoid any globally modifiable variables (for instance, we don't store the "current user" globally – it's always passed through function return values). The JWT verifier class holds state (the JWKS client, configuration) but it is self-contained and used in a controlled way. This makes our authentication component easy to reason about and test in isolation.

## Running and Testing the Authentication Layer

To test the implementation, follow these scenarios:

### Development Mode (Local Auth)

1. **Configure dev mode**: Ensure the environment variable is set to indicate development. For example, `ENV=development` or `USE_AUTH0=false` (depending on how you implemented the toggle). Also set `DEV_SECRET` in your config if you want to override the default secret.
2. **Run the FastAPI app** (e.g., using Uvicorn).
3. **Test the login**: Send a request to `POST /auth/login` with JSON body `{"username": "testuser", "password": "testpass"}` (adjust if you changed the dummy credentials). You should receive a JSON response with an `access_token`.
4. **Use the token**: Copy the token and send a request to `GET /auth/verify` with header `Authorization: Bearer <your_token>`. You should get a response containing the `authenticated_user` details (id, email, name) that were embedded in the token.
5. **Test a protected endpoint**: If you have other endpoints protected by `get_current_user`, try accessing them with and without a valid token to ensure they behave as expected (200 OK with token, 401 without).
6. **Invalid token tests**: You can also test error cases, for example:
   - Call `/auth/verify` without any `Authorization` header (should get 401).
   - Call with a malformed token (e.g., `Authorization: Bearer abc.def.ghi` which is not a valid JWT structure) to see it rejects.
   - Call with a valid JWT but signed with the wrong key (if you can generate one) to ensure it’s rejected. In dev mode, an easy way is to change the `DEV_SECRET` after generating a token, then try to use the old token.

These tests ensure your dev stub is working and secure enough (though it's just for dev, it's good to catch any logic errors).

### Production Mode (Auth0 Integration)

1. **Configure production mode**: Set environment variables for Auth0:
   - `USE_AUTH0=true` (or `ENV=production`).
   - `AUTH0_DOMAIN=<your Auth0 domain>` (e.g., `example.us.auth0.com`).
   - `AUTH0_AUDIENCE=<your API audience identifier>` (as configured in Auth0).
   - Ensure your `DEV_SECRET` or the login route won't be used (the code already prevents it in this mode).
2. **Obtain a token**: There are a few ways to get a JWT from Auth0 for testing:
   - If you have a Single Page Application or another client set up with Auth0, perform a login and get an access token for your API (the token should have your API's audience).
   - Use Auth0's Test panel: in the Auth0 dashboard, find your API, and there is often a "Test" tab where you can get a sample access token for a user.
   - Use Auth0's Authentication API: e.g., call the `/oauth/token` endpoint with client credentials (if you have a Machine-to-Machine application for your API).
     However you do it, get a JWT access token that the Auth0 integration issues.
3. **Call the protected endpoint**: With the token from Auth0, make a request to `GET /auth/verify` with `Authorization: Bearer <token>`. If everything is set up correctly:
   - The server will fetch the JWKS from your Auth0 domain (this happens on first request; subsequent verifications may reuse the cached keys).
   - It will find the key that matches your token and verify the signature.
   - If the token is valid (not expired, correct audience, etc.), you'll get back the user info. The `sub` will likely be an Auth0 user ID string (like `auth0|abc123...`), and if your token includes email/name, those will appear too. If the token didn't include those, you'll at least have the `sub` (which you can correlate to user info via Auth0 if needed).
   - If something is wrong (e.g., token expired or audience mismatch), you should get a 401 error.
4. **Test other endpoints**: As before, test any other protected routes in your API with the Auth0 token. They should similarly authorize or reject requests.

During development of the Auth0 mode, it's helpful to have logging around the token verification to troubleshoot issues (for example, log the error message if jwt.decode raises). But for the final implementation, you might not want to leak sensitive info in logs. For the MVP, focus on getting it working first.

### Switching Modes

To switch between dev and production mode, you simply change the environment flag and restart the app. The code paths are mostly separate thanks to our `USE_AUTH0` checks:

- In dev mode, the JWKS client is not used at all, and the login endpoint is enabled.
- In prod mode, the login endpoint is disabled and any attempt to use it returns 404. All tokens are expected to be Auth0 tokens.
- You can even simulate Auth0 mode locally by setting up a test Auth0 tenant and using its tokens; the server doesn't care where it runs, as long as it can reach the Auth0 JWKS URL (which is public on the internet).

This toggle approach makes it easy to develop locally and deploy securely, without maintaining two separate codebases or heavy config changes.

## Extensibility and Next Steps

The authentication layer we implemented is minimal yet functional. It can be extended or modified in a few safe ways:

- **Using Authlib instead of PyJWT**: If preferred, Authlib can handle JWKS and JWT verification. The core idea remains the same (fetch key, verify signature). Replacing the library is straightforward since we haven't entangled it in complex custom code.
- **Caching JWKS**: The PyJWKClient we used already caches keys by default, but if you find performance issues on token verification, you could instantiate the `Auth0JWTVerifier` as a single global instance (as we did) so that it does not refetch JWKS for every request. Our implementation using a class already facilitates reuse of the JWKS client. No further action is needed unless you want to pre-fetch keys or handle key rotation more explicitly.
- **Adjusting token claims**: Our `get_current_user` currently extracts `sub`, `email`, `name`. If your Auth0 tokens have different or additional claims (for example, `nickname`, `picture`, or custom claims), you can enrich the user object accordingly. Also, if you want to enforce certain claims (like checking `email_verified` is true), you can do that in the dependency as well.
- **Integrating with a user database**: In some systems, once you get the `sub` from the token, you might look up a user record in your database to get roles or other info. Our guide didn't include a DB call because the MVP did not require it and to keep concerns separate. If needed, you could inject a user service or database session into `get_current_user` to fetch additional details (or do it in the route handler after getting `current_user`). This is an extension point that does not break the core JWT verification logic.
- **Replacing Auth0**: If in the future you switch to a different identity provider (say, AWS Cognito, Okta, or a custom JWT issuer), you can reuse most of this code. You'd update the JWKS URL or how the public keys are fetched, and adjust the expected issuer/audience, but the structure (a dependency function verifying JWTs) stays the same. The `Auth0JWTVerifier` class name could become a generic `JWTVerifier` with configurable JWKS URL.
- **Adding Authorization (roles/scopes)**: We focused on authentication (identifying the user). Authorization (controlling access based on roles or scopes) can be built on top of this. For example, you can include role or scope claims in the JWT and then check them in either the dependency or in individual routes. FastAPI's `SecurityScopes` (as seen in the Auth0 sample code) can help with scope verification. This can be added without altering the fundamental JWT validation – it's an extra layer of checks on the decoded token. The `_check_claims` method in the sample code (which we did not explicitly implement here) is an example of how to enforce scopes.
- **Testing**: The authentication component can be unit tested by mocking tokens:
  - Provide a valid token (maybe using a library to generate one with the dev secret or a known RSA key) and ensure `get_current_user` returns a user.
  - Provide an invalid token and ensure it raises an HTTPException.
  - Test the dev login endpoint by posting known credentials and checking for a token in response.
  - These tests can run in isolation by setting `USE_AUTH0` accordingly and not depending on external Auth0 service (for Auth0 mode tests, you could still avoid network calls by mocking `PyJWKClient.get_signing_key_from_jwt` to return a known key).

Following the above guide, you have a solid starting point for Auth0-based authentication in the Cortex Core project, with a convenient dev mode for local development. The solution emphasizes clarity and simplicity: there's essentially one moving part (the JWT verification) with two variations, and everything is kept as straightforward as possible. This aligns with the project's philosophy and should be easy to maintain and extend as needed.

## Conclusion

We implemented a focused authentication layer that secures FastAPI endpoints with JWT verification, using Auth0 for production and a stub for development. The approach uses direct library features without over-engineering, ensuring the code is easy to follow. You can now confidently protect API routes, knowing only requests with valid tokens (from Auth0 or your dev login) will be allowed through. As the project grows, this auth layer can evolve (to integrate more features or different providers) but its foundational simplicity will help keep those future changes manageable.
