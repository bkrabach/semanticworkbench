<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cortex Core MCP Test Client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .panel {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }
        h2 {
            margin-top: 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        .red-button {
            background-color: #f44336;
        }
        .red-button:hover {
            background-color: #d32f2f;
        }
        .blue-button {
            background-color: #2196F3;
        }
        .blue-button:hover {
            background-color: #0b7dda;
        }
        .purple-button {
            background-color: #9c27b0;
        }
        .purple-button:hover {
            background-color: #7b1fa2;
        }
        .orange-button {
            background-color: #ff9800;
        }
        .orange-button:hover {
            background-color: #e68a00;
        }
        #messages {
            height: 300px;
            overflow-y: scroll;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
        }
        .context-panel {
            background-color: #f0f8ff;
            border: 1px solid #b0c4de;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }
        .message {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
        }
        .input-message {
            background-color: #e3f2fd;
        }
        .output-message {
            background-color: #f1f8e9;
        }
        .system-message {
            background-color: #f5f5f5;
            font-style: italic;
            color: #666;
        }
        .context-message {
            background-color: #fff3e0;
            border-left: 3px solid #ff9800;
        }
        .analysis-message {
            background-color: #e8eaf6;
            border-left: 3px solid #3f51b5;
        }
        .search-message {
            background-color: #e0f2f1;
            border-left: 3px solid #009688;
        }
        .error {
            color: red;
            margin-bottom: 10px;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #ccc;
            margin-bottom: 10px;
        }
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #f1f1f1;
            margin-right: 2px;
            border-radius: 4px 4px 0 0;
            border: 1px solid #ccc;
            border-bottom: none;
        }
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
        }
        .tab-content {
            display: none;
            padding: 10px;
            border: 1px solid #ccc;
            border-top: none;
        }
        .tab-content.active {
            display: block;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 14px;
        }
        .json-viewer {
            font-family: monospace;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .toggle-button {
            background: none;
            border: none;
            color: #2196F3;
            cursor: pointer;
            padding: 0;
            margin: 0;
            font-size: 0.9em;
        }
        .expandable {
            display: none;
            margin-top: 5px;
            padding: 5px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cortex Core MCP Test Client</h1>
        <p>This specialized client helps test Phase 3 MCP and Cognition Service features.</p>
        
        <!-- Authentication Panel -->
        <div class="panel" id="auth-panel">
            <h2>Authentication</h2>
            <div>
                <label for="email">Email:</label>
                <input type="email" id="email" value="user@example.com">
            </div>
            <div>
                <label for="password">Password:</label>
                <input type="password" id="password" value="password123">
            </div>
            <button id="login-btn">Login</button>
            <div id="auth-status" class="error"></div>
        </div>
        
        <!-- Workspace and Conversation Selection -->
        <div class="panel" id="workspace-panel" style="display: none;">
            <h2>Workspace & Conversation</h2>
            <div class="grid">
                <div>
                    <label for="workspace-select">Select Workspace:</label>
                    <select id="workspace-select">
                        <option value="">-- Select Workspace --</option>
                    </select>
                    <button id="refresh-workspaces-btn">Refresh Workspaces</button>
                </div>
                <div id="conversation-container" style="display: none;">
                    <label for="conversation-select">Select Conversation:</label>
                    <select id="conversation-select">
                        <option value="">-- Select Conversation --</option>
                    </select>
                    <button id="refresh-conversations-btn">Refresh Conversations</button>
                    <button id="create-conversation-btn">+ New Conversation</button>
                </div>
            </div>
        </div>
        
        <!-- MCP Features Panel -->
        <div class="panel" id="mcp-panel" style="display: none;">
            <h2>MCP Phase 3 Features</h2>
            
            <div class="tabs">
                <div class="tab active" data-tab="chat">Chat</div>
                <div class="tab" data-tab="context">Context Retrieval</div>
                <div class="tab" data-tab="analysis">Conversation Analysis</div>
                <div class="tab" data-tab="search">History Search</div>
            </div>
            
            <!-- Chat Tab -->
            <div class="tab-content active" id="chat-tab">
                <h3>Chat with Context</h3>
                <div id="messages"></div>
                <div>
                    <label for="message-input">Message:</label>
                    <textarea id="message-input" rows="3"></textarea>
                    <div style="display: flex; gap: 10px; margin: 10px 0;">
                        <label for="context-toggle" style="display: flex; align-items: center;">
                            <input type="checkbox" id="context-toggle" checked> Use context from Cognition Service
                        </label>
                        <label for="streaming-toggle" style="display: flex; align-items: center;">
                            <input type="checkbox" id="streaming-toggle" checked> Enable streaming preview
                        </label>
                    </div>
                    <div class="context-panel" id="context-preview">
                        <h4>Context Preview (will be used for next message)</h4>
                        <div id="context-items">No context retrieved yet</div>
                    </div>
                    <button id="send-btn">Send Message</button>
                    <button id="clear-messages-btn" class="red-button">Clear Messages</button>
                </div>
                <div>
                    <p>Communication Mode:</p>
                    <button id="sse-btn" class="blue-button">Connect SSE</button>
                    <button id="stop-comm-btn" class="red-button">Stop Connection</button>
                </div>
            </div>
            
            <!-- Context Retrieval Tab -->
            <div class="tab-content" id="context-tab">
                <h3>Context Retrieval Testing</h3>
                <div>
                    <label for="context-query">Query (optional):</label>
                    <input type="text" id="context-query" placeholder="Enter query to filter context">
                    
                    <label for="context-limit">Result Limit:</label>
                    <input type="number" id="context-limit" value="5" min="1" max="50">
                    
                    <label for="recency-weight">Recency Weight (0-1):</label>
                    <input type="number" id="recency-weight" value="0.5" min="0" max="1" step="0.1">
                    
                    <button id="get-context-btn" class="blue-button">Get Context</button>
                </div>
                <div class="context-panel">
                    <h4>Context Results</h4>
                    <div id="context-results">Run a context query to see results</div>
                </div>
            </div>
            
            <!-- Conversation Analysis Tab -->
            <div class="tab-content" id="analysis-tab">
                <h3>Conversation Analysis Testing</h3>
                <div>
                    <label for="analysis-type">Analysis Type:</label>
                    <select id="analysis-type">
                        <option value="summary">Summary</option>
                        <option value="topics">Topic Extraction</option>
                        <option value="sentiment">Sentiment Analysis</option>
                    </select>
                    
                    <button id="analyze-btn" class="purple-button">Analyze Conversation</button>
                </div>
                <div class="context-panel">
                    <h4>Analysis Results</h4>
                    <div id="analysis-results">Run an analysis to see results</div>
                </div>
            </div>
            
            <!-- History Search Tab -->
            <div class="tab-content" id="search-tab">
                <h3>History Search Testing</h3>
                <div>
                    <label for="search-query">Search Query:</label>
                    <input type="text" id="search-query" placeholder="Enter search terms">
                    
                    <label for="search-limit">Result Limit:</label>
                    <input type="number" id="search-limit" value="5" min="1" max="50">
                    
                    <label for="include-conversations">
                        <input type="checkbox" id="include-conversations" checked> Include conversation data
                    </label>
                    
                    <button id="search-btn" class="orange-button">Search History</button>
                </div>
                <div class="context-panel">
                    <h4>Search Results</h4>
                    <div id="search-results">Run a search to see results</div>
                </div>
            </div>
        </div>
        
        <!-- MCP Debug Panel -->
        <div class="panel" id="debug-panel" style="display: none;">
            <h2>MCP Debug Information</h2>
            <div class="tabs">
                <div class="tab active" data-tab="last-response">Last Response</div>
                <div class="tab" data-tab="api-endpoints">API Endpoints</div>
            </div>
            
            <!-- Last Response Tab -->
            <div class="tab-content active" id="last-response-tab">
                <h3>Last API Response</h3>
                <pre id="last-response-json" class="json-viewer">No API calls made yet</pre>
            </div>
            
            <!-- API Endpoints Tab -->
            <div class="tab-content" id="api-endpoints-tab">
                <h3>MCP API Reference</h3>
                <pre>
# API Endpoints (v1)

# Status and Health
GET  /                                         - Basic status endpoint
GET  /health                                   - Simple health check
GET  /v1/health                                - Detailed health status with system info

# Authentication
POST /v1/auth/login                            - Login with credentials 
GET  /v1/auth/verify                           - Verify authentication token

# Cognition API
POST /v1/context                               - Get relevant context for conversations
POST /v1/analyze                               - Analyze a conversation
POST /v1/search                                - Search through conversation history

# Messages
POST /v1/conversation/{id}/messages            - Send message to a conversation
GET  /v1/conversation/{id}/messages/stream     - Receive SSE events with responses

# Resources
GET  /v1/workspace                             - List workspaces
POST /v1/workspace                             - Create a workspace
GET  /v1/workspace/{id}                        - Get workspace details
PUT  /v1/workspace/{id}                        - Update workspace
DELETE /v1/workspace/{id}                      - Delete workspace

GET  /v1/conversation                          - List conversations
POST /v1/conversation                          - Create a conversation
GET  /v1/conversation/{id}                     - Get conversation details
PUT  /v1/conversation/{id}                     - Update conversation
DELETE /v1/conversation/{id}                   - Delete conversation
                </pre>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let token = null;
        let user = null;
        let selectedWorkspaceId = null;
        let selectedConversationId = null;
        let sseController = null;
        let lastContextResult = null;
        let lastApiResponse = null;
        
        // Message tracking for all conversations
        let messageTracking = {};
        
        // Active message elements in the UI - tracks current message IDs by type
        let activeMessages = {
            // conversation_id -> { user: messageId, response: messageId, tool: messageId }
        };

        // Base API URL
        const API_URL = 'http://localhost:8000';

        // Add event listeners after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Auth panel
            document.getElementById('login-btn').addEventListener('click', login);
            
            // Workspace and conversation panel
            document.getElementById('workspace-select').addEventListener('change', handleWorkspaceSelect);
            document.getElementById('refresh-workspaces-btn').addEventListener('click', loadWorkspaces);
            document.getElementById('conversation-select').addEventListener('change', handleConversationSelect);
            document.getElementById('refresh-conversations-btn').addEventListener('click', function() {
                if (selectedWorkspaceId) {
                    loadConversations(selectedWorkspaceId);
                }
            });
            document.getElementById('create-conversation-btn').addEventListener('click', showCreateConversationForm);
            
            // Chat tab
            document.getElementById('send-btn').addEventListener('click', sendMessage);
            document.getElementById('sse-btn').addEventListener('click', connectToSSE);
            document.getElementById('stop-comm-btn').addEventListener('click', stopCommunication);
            document.getElementById('clear-messages-btn').addEventListener('click', clearMessages);
            document.getElementById('context-toggle').addEventListener('change', function() {
                if (this.checked) {
                    document.getElementById('context-preview').style.display = 'block';
                    getContextPreview();
                } else {
                    document.getElementById('context-preview').style.display = 'none';
                }
            });
            document.getElementById('streaming-toggle').addEventListener('change', function() {
                // No visual changes needed, the preference is used when sending messages
                console.log(`Streaming preference changed to: ${this.checked}`);
            });
            
            // Add Enter and Shift+Enter handling for message input
            document.getElementById('message-input').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    if (!e.shiftKey) {
                        // Enter without shift - submit message
                        e.preventDefault();
                        sendMessage();
                    }
                    // Shift+Enter creates a newline naturally (default behavior)
                }
            });
            
            // Context tab
            document.getElementById('get-context-btn').addEventListener('click', getContext);
            
            // Analysis tab
            document.getElementById('analyze-btn').addEventListener('click', analyzeConversation);
            
            // Search tab
            document.getElementById('search-btn').addEventListener('click', searchHistory);
            
            // Tab navigation
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    showTab(tabName);
                });
            });
        });

        // Tab navigation function
        function showTab(tabName) {
            // Hide all tabs and remove active class
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show the selected tab and add active class
            document.getElementById(`${tabName}-tab`).classList.add('active');
            document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
        }

        // Authentication
        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const authStatus = document.getElementById('auth-status');
            
            // Validation
            if (!email || !password) {
                authStatus.textContent = 'Please enter email and password';
                return;
            }
            
            try {
                // FastAPI OAuth2 expects form urlencoded data
                const formData = new URLSearchParams();
                formData.append('username', email);
                formData.append('password', password);
                
                const response = await fetch(`${API_URL}/v1/auth/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: formData
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Authentication failed: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Store token and user data
                token = data.access_token;
                user = data.claims;
                
                // Show success message
                authStatus.textContent = 'Authentication successful!';
                authStatus.style.color = 'green';
                
                // Show panels
                document.getElementById('workspace-panel').style.display = 'block';
                document.getElementById('debug-panel').style.display = 'block';
                
                // Load workspaces
                loadWorkspaces();
                
                // Add to log
                addMessage('system', `Logged in as ${user.name} (${user.email})`);
                
            } catch (error) {
                authStatus.textContent = error.message;
                console.error('Login error:', error);
            }
        }

        // Load workspaces
        async function loadWorkspaces() {
            if (!token) {
                addMessage('system', 'Not authenticated. Please login first.');
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/v1/workspace`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Failed to load workspaces: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Clear and populate dropdown
                const workspaceSelect = document.getElementById('workspace-select');
                workspaceSelect.innerHTML = '<option value="">-- Select Workspace --</option>';
                
                if (data.workspaces && data.workspaces.length > 0) {
                    data.workspaces.forEach(workspace => {
                        const option = document.createElement('option');
                        option.value = workspace.id;
                        option.textContent = workspace.name;
                        workspaceSelect.appendChild(option);
                    });
                    
                    addMessage('system', `Loaded ${data.workspaces.length} workspaces`);
                    
                    // Add create button next to select
                    if (!document.getElementById('create-workspace-btn')) {
                        const createBtn = document.createElement('button');
                        createBtn.id = 'create-workspace-btn';
                        createBtn.textContent = '+ New Workspace';
                        createBtn.addEventListener('click', showCreateWorkspaceForm);
                        workspaceSelect.parentNode.appendChild(createBtn);
                    }
                } else {
                    addMessage('system', 'No workspaces found. Create one to get started.');
                    
                    // Add create button if it doesn't exist
                    if (!document.getElementById('create-workspace-btn')) {
                        const createBtn = document.createElement('button');
                        createBtn.id = 'create-workspace-btn';
                        createBtn.textContent = '+ New Workspace';
                        createBtn.addEventListener('click', showCreateWorkspaceForm);
                        workspaceSelect.parentNode.appendChild(createBtn);
                    }
                }
                
            } catch (error) {
                addMessage('system', error.message);
                console.error('Load workspaces error:', error);
            }
        }

        // Handle workspace selection
        function handleWorkspaceSelect() {
            const workspaceSelect = document.getElementById('workspace-select');
            const selectedValue = workspaceSelect.value;
            const conversationContainer = document.getElementById('conversation-container');
            
            if (selectedValue) {
                selectedWorkspaceId = selectedValue;
                // Show conversation container
                conversationContainer.style.display = 'block';
                // Load conversations for this workspace
                loadConversations(selectedWorkspaceId);
                
                // Log
                const workspaceName = workspaceSelect.options[workspaceSelect.selectedIndex].text;
                addMessage('system', `Selected workspace: ${workspaceName}`);
                
                // Make sure conversation button has the right event listener
                document.getElementById('create-conversation-btn').addEventListener('click', showCreateConversationForm);
            } else {
                // Hide conversation container
                conversationContainer.style.display = 'none';
                // Reset conversation dropdown and hide MCP panel
                document.getElementById('conversation-select').innerHTML = '<option value="">-- Select Conversation --</option>';
                document.getElementById('mcp-panel').style.display = 'none';
                selectedConversationId = null;
            }
        }
        
        // Show form to create a new workspace
        function showCreateWorkspaceForm() {
            // Create form container
            const formContainer = document.createElement('div');
            formContainer.className = 'form-popup';
            formContainer.id = 'create-workspace-form';
            formContainer.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ddd; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 100;';
            
            formContainer.innerHTML = `
                <h3>Create New Workspace</h3>
                <label for="new-workspace-name">Workspace Name:</label>
                <input type="text" id="new-workspace-name" value="My Workspace" style="width: 100%; margin: 10px 0;">
                <label for="new-workspace-description">Description:</label>
                <textarea id="new-workspace-description" placeholder="Enter workspace description" style="width: 100%; margin: 10px 0;" rows="3">General workspace for testing</textarea>
                <div style="display: flex; justify-content: flex-end; gap: 10px;">
                    <button id="cancel-workspace-btn" style="background-color: #ddd; color: black;">Cancel</button>
                    <button id="confirm-workspace-btn">Create</button>
                </div>
            `;
            
            document.body.appendChild(formContainer);
            
            // Add event listeners
            document.getElementById('cancel-workspace-btn').addEventListener('click', () => {
                document.body.removeChild(formContainer);
            });
            
            document.getElementById('confirm-workspace-btn').addEventListener('click', () => {
                const workspaceName = document.getElementById('new-workspace-name').value.trim();
                if (workspaceName) {
                    createNewWorkspace(workspaceName);
                    document.body.removeChild(formContainer);
                }
            });
            
            // Focus the input
            document.getElementById('new-workspace-name').focus();
            document.getElementById('new-workspace-name').select();
        }
        
        // Create new workspace
        async function createNewWorkspace(name) {
            if (!token) {
                addMessage('system', 'Not authenticated. Please login first.');
                return;
            }
            
            // Get description from form
            const description = document.getElementById('new-workspace-description').value.trim();
            
            try {
                const response = await fetch(`${API_URL}/v1/workspace`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: name,
                        description: description
                    })
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Failed to create workspace: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Reload workspaces and select the new one
                await loadWorkspaces();
                
                // Find and select the newly created workspace
                const workspaceSelect = document.getElementById('workspace-select');
                const options = Array.from(workspaceSelect.options);
                const newOption = options.find(option => option.textContent === name);
                
                if (newOption) {
                    workspaceSelect.value = newOption.value;
                    selectedWorkspaceId = newOption.value;
                    
                    // Show conversation container
                    document.getElementById('conversation-container').style.display = 'block';
                    
                    // Load conversations for this workspace (will be empty initially)
                    loadConversations(selectedWorkspaceId);
                }
                
                addMessage('system', `Created new workspace: ${name}`);
                
            } catch (error) {
                addMessage('system', error.message);
                console.error('Create workspace error:', error);
            }
        }

        // Load conversations
        async function loadConversations(workspaceId) {
            if (!token) {
                addMessage('system', 'Not authenticated. Please login first.');
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/v1/conversation?workspace_id=${workspaceId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Failed to load conversations: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Clear and populate dropdown
                const conversationSelect = document.getElementById('conversation-select');
                conversationSelect.innerHTML = '<option value="">-- Select Conversation --</option>';
                
                if (data.conversations && data.conversations.length > 0) {
                    data.conversations.forEach(conversation => {
                        const option = document.createElement('option');
                        option.value = conversation.id;
                        option.textContent = conversation.topic;
                        conversationSelect.appendChild(option);
                    });
                    
                    addMessage('system', `Loaded ${data.conversations.length} conversations`);
                } else {
                    addMessage('system', 'No conversations found in this workspace. Create one to get started.');
                }
                
            } catch (error) {
                addMessage('system', error.message);
                console.error('Load conversations error:', error);
            }
        }

        // Handle conversation selection
        function handleConversationSelect() {
            const conversationSelect = document.getElementById('conversation-select');
            const selectedValue = conversationSelect.value;
            
            if (selectedValue) {
                selectedConversationId = selectedValue;
                
                // Show MCP panel
                document.getElementById('mcp-panel').style.display = 'block';
                
                // Clear messages
                clearMessages();
                
                // Initialize this conversation's message container
                if (!activeMessages[selectedConversationId]) {
                    activeMessages[selectedConversationId] = {};
                }
                
                // Load conversation history
                loadConversationHistory(selectedConversationId);
                
                // Log
                const conversationTopic = conversationSelect.options[conversationSelect.selectedIndex].text;
                addMessage('system', `Selected conversation: ${conversationTopic}`);
                
                // Auto-connect SSE when conversation is selected
                connectToSSE();
                
                // Get context preview
                getContextPreview();
            } else {
                // Stop SSE connection if active
                stopCommunication();
                
                // Hide MCP panel if no conversation selected
                document.getElementById('mcp-panel').style.display = 'none';
                selectedConversationId = null;
            }
        }
        
        // Show form to create a new conversation
        function showCreateConversationForm() {
            if (!selectedWorkspaceId) {
                addMessage('system', 'Please select a workspace first.');
                return;
            }
            
            // Create form container
            const formContainer = document.createElement('div');
            formContainer.className = 'form-popup';
            formContainer.id = 'create-conversation-form';
            formContainer.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ddd; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 100;';
            
            formContainer.innerHTML = `
                <h3>Create New Conversation</h3>
                <label for="new-conversation-topic">Conversation Topic:</label>
                <input type="text" id="new-conversation-topic" value="New Conversation" style="width: 100%; margin: 10px 0;">
                <div style="display: flex; justify-content: flex-end; gap: 10px;">
                    <button id="cancel-conversation-btn" style="background-color: #ddd; color: black;">Cancel</button>
                    <button id="confirm-conversation-btn">Create</button>
                </div>
            `;
            
            document.body.appendChild(formContainer);
            
            // Add event listeners
            document.getElementById('cancel-conversation-btn').addEventListener('click', () => {
                document.body.removeChild(formContainer);
            });
            
            document.getElementById('confirm-conversation-btn').addEventListener('click', () => {
                const conversationTopic = document.getElementById('new-conversation-topic').value.trim();
                if (conversationTopic) {
                    createNewConversation(conversationTopic);
                    document.body.removeChild(formContainer);
                }
            });
            
            // Focus the input
            document.getElementById('new-conversation-topic').focus();
            document.getElementById('new-conversation-topic').select();
        }
        
        // Create new conversation
        async function createNewConversation(topic) {
            if (!token || !selectedWorkspaceId) {
                addMessage('system', 'Not authenticated or no workspace selected.');
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/v1/conversation`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        topic: topic,
                        workspace_id: selectedWorkspaceId
                    })
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Failed to create conversation: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Reload conversations and select the new one
                await loadConversations(selectedWorkspaceId);
                
                // Find and select the newly created conversation
                const conversationSelect = document.getElementById('conversation-select');
                const options = Array.from(conversationSelect.options);
                const newOption = options.find(option => option.textContent === topic);
                
                if (newOption) {
                    conversationSelect.value = newOption.value;
                    selectedConversationId = newOption.value;
                    handleConversationSelect();
                }
                
                addMessage('system', `Created new conversation: ${topic}`);
                
            } catch (error) {
                addMessage('system', error.message);
                console.error('Create conversation error:', error);
            }
        }
        
        // Load conversation history from the server
        async function loadConversationHistory(conversationId) {
            if (!token || !conversationId) {
                return;
            }
            
            try {
                addMessage('system', 'Loading conversation history...');
                
                // First try to get the conversation details with messages from the config API
                const configResponse = await fetch(`${API_URL}/v1/conversation/${conversationId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (configResponse.ok) {
                    const data = await configResponse.json();
                    if (data.conversation && data.conversation.messages && data.conversation.messages.length > 0) {
                        // Display messages from newest to oldest
                        const messages = data.conversation.messages.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                        
                        // Add messages to UI
                        for (const message of messages) {
                            const messageType = message.sender_id === user.user_id ? 'user' : 'assistant';
                            updateOrCreateMessage(selectedConversationId, message.id, messageType, message.content);
                        }
                        
                        addMessage('system', `Loaded ${messages.length} messages from history`);
                        return;
                    }
                }
                
                // If the API request returned no messages, just display a message
                addMessage('system', 'No message history found for this conversation');
                
            } catch (error) {
                console.error('Error loading conversation history:', error);
                addMessage('system', `Error loading conversation history: ${error.message}`);
            }
        }

        // Find a matching user message by content to avoid duplication
        function findMatchingUserMessage(content) {
            // Look for messages with the right class and content
            const messagesContainer = document.getElementById('messages');
            const messageElements = messagesContainer.querySelectorAll('.message.input-message');
            
            for (const element of messageElements) {
                const messageText = element.textContent.replace('You: ', '');
                if (messageText === content) {
                    return element;
                }
            }
            
            return null;
        }
        
        // Send message with context
        async function sendMessage() {
            if (!token) {
                addMessage('system', 'Not authenticated. Please login first.');
                return;
            }
            
            if (!selectedConversationId) {
                addMessage('system', 'No conversation selected. Please select a conversation first.');
                return;
            }
            
            const messageInput = document.getElementById('message-input');
            const content = messageInput.value.trim();
            
            if (!content) {
                addMessage('system', 'Please enter a message to send.');
                return;
            }
            
            const useContext = document.getElementById('context-toggle').checked;
            
            try {
                // Get streaming preference
                const streamingEnabled = document.getElementById('streaming-toggle').checked;
                
                const messageData = {
                    content,
                    conversation_id: selectedConversationId,
                    streaming: streamingEnabled,
                    metadata: {
                        client_id: 'mcp-test-client',
                        client_version: '1.0.0',
                        use_context: useContext
                    }
                };
                
                // If we have context and it should be used, add it to metadata
                if (useContext && lastContextResult) {
                    messageData.metadata.context = lastContextResult;
                }
                
                // Generate a temporary client-side ID for optimistic UI update
                const tempMessageId = `user-temp-${Date.now()}`;
                
                // Create optimistic UI update first (will be replaced with server ID)
                const msgElement = updateOrCreateMessage(
                    selectedConversationId, 
                    tempMessageId, 
                    'user', 
                    content
                );
                
                // Mark this element with a data attribute so we can identify it later
                const messageElement = document.getElementById(`msg-${tempMessageId}`);
                if (messageElement) {
                    messageElement.dataset.tempId = tempMessageId;
                }
                
                // Send message to server
                const response = await fetch(`${API_URL}/v1/conversation/${selectedConversationId}/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify(messageData)
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Message sent successfully:', data);
                
                // If server returns a message ID, update our tracking with it
                // (The actual UI update will happen via SSE events)
                if (data.message_id) {
                    // The next SSE event will handle replacing the temporary message
                    console.log(`Message sent with server ID: ${data.message_id}`);
                    
                    // If server responds quickly, we could update here
                    // For now we'll let the SSE event handler take care of it
                }
                
                // Clear input
                messageInput.value = '';
                
                // Get new context preview for next message
                if (useContext) {
                    getContextPreview();
                }
                
            } catch (error) {
                addMessage('system', error.message);
                console.error('Send message error:', error);
            }
        }

        // Get context preview for the next message
        async function getContextPreview() {
            if (!token || !selectedConversationId || !user) {
                return;
            }
            
            try {
                // Get message input content as query if available
                const messageInput = document.getElementById('message-input');
                const content = messageInput.value.trim();
                
                const response = await fetch(`${API_URL}/v1/context`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        query: content || null,
                        limit: 3
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to get context: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Store for later use
                lastContextResult = data.data;
                
                // Display in the preview panel
                const contextItems = document.getElementById('context-items');
                contextItems.innerHTML = '';
                
                if (data.data.context && data.data.context.length > 0) {
                    data.data.context.forEach(item => {
                        const div = document.createElement('div');
                        div.className = 'context-message';
                        div.innerHTML = `<strong>${formatTimestamp(item.timestamp)}</strong>: ${item.content}`;
                        contextItems.appendChild(div);
                    });
                    
                    contextItems.innerHTML += `<div><small>${data.data.count} items found${data.data.query ? ` for query "${data.data.query}"` : ''}</small></div>`;
                } else {
                    contextItems.textContent = 'No relevant context found';
                }
                
            } catch (error) {
                console.error('Context preview error:', error);
                const contextItems = document.getElementById('context-items');
                contextItems.textContent = `Error getting context: ${error.message}`;
            }
        }

        // Connect to SSE
        async function connectToSSE() {
            // Stop any existing communication
            stopCommunication();
            
            if (!token) {
                addMessage('system', 'Not authenticated. Please login first.');
                return;
            }
            
            if (!selectedConversationId) {
                addMessage('system', 'No conversation selected. Please select a conversation first.');
                return;
            }
            
            addMessage('system', 'Connecting to SSE...');
            
            try {
                // Define a simple fetch-based EventSource implementation for auth headers
                class AuthEventSource {
                    constructor(url, token) {
                        this.url = url;
                        this.token = token;
                        this.eventListeners = {
                            'open': [],
                            'message': [],
                            'error': []
                        };
                        this.controller = new AbortController();
                        this.connect();
                    }
                    
                    connect() {
                        fetch(this.url, {
                            headers: {
                                'Authorization': `Bearer ${this.token}`,
                                'Accept': 'text/event-stream'
                            },
                            signal: this.controller.signal
                        }).then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            
                            // Connection is open
                            this._dispatch('open', new Event('open'));
                            
                            // Read the stream
                            const reader = response.body.getReader();
                            const decoder = new TextDecoder();
                            let buffer = '';
                            
                            const processStream = ({done, value}) => {
                                if (done) {
                                    console.log('Stream complete');
                                    return;
                                }
                                
                                // Process received data
                                buffer += decoder.decode(value, {stream: true});
                                const lines = buffer.split('\n\n');
                                buffer = lines.pop() || '';
                                
                                for (const line of lines) {
                                    if (line.trim()) {
                                        const eventData = line.replace('data: ', '');
                                        const messageEvent = new MessageEvent('message', {
                                            data: eventData
                                        });
                                        this._dispatch('message', messageEvent);
                                    }
                                }
                                
                                // Continue reading
                                return reader.read().then(processStream);
                            };
                            
                            reader.read().then(processStream);
                        }).catch(error => {
                            console.error('SSE fetch error:', error);
                            this._dispatch('error', new ErrorEvent('error', {
                                message: error.message
                            }));
                        });
                    }
                    
                    _dispatch(type, event) {
                        for (const handler of this.eventListeners[type]) {
                            handler(event);
                        }
                    }
                    
                    addEventListener(type, callback) {
                        if (this.eventListeners[type]) {
                            this.eventListeners[type].push(callback);
                        }
                    }
                    
                    removeEventListener(type, callback) {
                        if (this.eventListeners[type]) {
                            this.eventListeners[type] = this.eventListeners[type].filter(cb => cb !== callback);
                        }
                    }
                    
                    close() {
                        this.controller.abort();
                    }
                }
                
                // Create AuthEventSource
                const source = new AuthEventSource(`${API_URL}/v1/conversation/${selectedConversationId}/messages/stream`, token);
                
                // Store for later cleanup
                window.eventSource = source;
                
                // Set up event handlers
                source.addEventListener('open', function() {
                    addMessage('system', 'SSE connection opened successfully!');
                });
                
                source.addEventListener('message', function(event) {
                    try {
                        console.log('Raw SSE event received:', event);
                        
                        const data = JSON.parse(event.data);
                        console.log('SSE event data parsed:', data);
                        
                        // Update last API response
                        lastApiResponse = data;
                        updateLastResponse();
                        
                        // Get conversation ID from the event
                        const conversationId = data.conversation_id || 
                            (data.data && data.data.conversation_id) || 
                            selectedConversationId;
                        
                        // Initialize tracking for this conversation if needed
                        if (conversationId && !messageTracking[conversationId]) {
                            messageTracking[conversationId] = {};
                        }
                        
                        // Track accumulated content for streaming
                        if (!messageTracking[conversationId]._streamContent) {
                            messageTracking[conversationId]._streamContent = "";
                        }
                        
                        // Standard event types (non-unified)
                        if (data.type === 'connection_established') {
                            addMessage('system', 'SSE Connection established');
                            return;
                        } else if (data.type === 'heartbeat') {
                            console.log('Heartbeat received');
                            return;
                        }
                        
                        // Handle unified message format
                        if (data.type === 'message' && data.data) {
                            const messageData = data.data;
                            const messageType = data.message_type;
                            const conversationId = messageData.conversation_id || selectedConversationId;
                            const messageId = messageData.message_id || `${messageType}-${Date.now()}`;
                            const content = messageData.content;
                            const inReplyTo = null; // in_reply_to field removed
                            // No longer need is_final flag
                            
                            // Initialize tracking for this conversation if needed
                            if (conversationId && !messageTracking[conversationId]) {
                                messageTracking[conversationId] = {
                                    _streamContent: ""
                                };
                            }
                            
                            // Process messages based on their type
                            switch (messageType) {
                                case 'user':
                                    // Find existing user message (optimistically rendered) to avoid duplicates
                                    const existingMessageElement = findMatchingUserMessage(content);
                                    
                                    if (existingMessageElement) {
                                        // Update the existing message element with server ID
                                        console.log('Found existing message with same content, updating with server ID');
                                        existingMessageElement.id = `msg-${messageId}`;
                                        existingMessageElement.dataset.messageId = messageId;
                                        
                                        // Update tracking
                                        if (existingMessageElement.dataset.tempId) {
                                            const tempId = existingMessageElement.dataset.tempId;
                                            // Remove temp ID from tracking if it exists
                                            if (messageTracking[conversationId][tempId]) {
                                                delete messageTracking[conversationId][tempId];
                                            }
                                        }
                                        
                                        // Add to tracking with server ID
                                        messageTracking[conversationId][messageId] = {
                                            type: 'user',
                                            content: content,
                                            timestamp: messageData.timestamp || new Date().toISOString()
                                        };
                                        
                                        // Update active message tracking
                                        activeMessages[conversationId].user = messageId;
                                    } else {
                                        // Rare case - server-sent user message without local optimistic render
                                        updateOrCreateMessage(
                                            conversationId, 
                                            messageId, 
                                            'user', 
                                            content
                                        );
                                    }
                                    break;
                                    
                                case 'assistant':
                                    // Final assistant response
                                    updateOrCreateMessage(
                                        conversationId,
                                        messageId,
                                        'assistant',
                                        content,
                                        inReplyTo
                                    );
                                    
                                    // Reset streaming content buffer
                                    messageTracking[conversationId]._streamContent = "";
                                    
                                    // Automatically refresh context after receiving final response
                                    if (document.getElementById('context-toggle').checked) {
                                        setTimeout(() => {
                                            getContextPreview();
                                        }, 500);
                                    }
                                    break;
                                    
                                case 'chunk':
                                    // Handle streaming response chunks
                                    if (!messageTracking[conversationId][messageId]) {
                                        messageTracking[conversationId]._streamContent = content;
                                    } else {
                                        messageTracking[conversationId]._streamContent += content;
                                    }
                                    
                                    const currentContent = messageTracking[conversationId]._streamContent;
                                    
                                    // Update or create response message with server ID
                                    // Mark this as a streaming preview by setting data attribute
                                    const msgElement = updateOrCreateMessage(
                                        conversationId,
                                        messageId,
                                        'assistant',
                                        currentContent,
                                        inReplyTo
                                    );
                                    
                                    // Add streaming indicator
                                    const streamElement = document.getElementById(`msg-${messageId}`);
                                    if (streamElement) {
                                        streamElement.dataset.streaming = "true";
                                        // Add a visual indicator that this is a streaming preview
                                        if (!streamElement.querySelector('.streaming-indicator')) {
                                            const indicator = document.createElement('small');
                                            indicator.className = 'streaming-indicator';
                                            indicator.textContent = ' (streaming preview)';
                                            indicator.style.fontStyle = 'italic';
                                            indicator.style.color = '#999';
                                            streamElement.appendChild(indicator);
                                        }
                                    }
                                    break;
                                    
                                case 'complete':
                                    // Handle response completion with the full content
                                    // The content property will contain the complete response
                                    // First check if we have streamed content
                                    const streamedContent = messageTracking[conversationId]._streamContent;
                                    
                                    // Use the explicit content from the complete event
                                    // This is the full message that serves as the source of truth
                                    const finalContent = content || streamedContent;
                                    
                                    if (finalContent) {
                                        // Update or create message with the final content
                                        updateOrCreateMessage(
                                            conversationId,
                                            messageId,
                                            'assistant',
                                            finalContent,
                                            inReplyTo
                                        );
                                        
                                        // Remove streaming indicator if it exists
                                        const msgElement = document.getElementById(`msg-${messageId}`);
                                        if (msgElement) {
                                            // Remove streaming indicator
                                            const indicator = msgElement.querySelector('.streaming-indicator');
                                            if (indicator) {
                                                msgElement.removeChild(indicator);
                                            }
                                            
                                            // Remove streaming data attribute
                                            delete msgElement.dataset.streaming;
                                            
                                            // Add final message indicator
                                            if (!msgElement.querySelector('.final-indicator')) {
                                                const finalIndicator = document.createElement('small');
                                                finalIndicator.className = 'final-indicator';
                                                finalIndicator.textContent = ' (complete)';
                                                finalIndicator.style.fontStyle = 'italic';
                                                finalIndicator.style.color = '#4CAF50';
                                                // Add to message but make it fade out after 2 seconds
                                                msgElement.appendChild(finalIndicator);
                                                setTimeout(() => {
                                                    finalIndicator.style.transition = 'opacity 1s';
                                                    finalIndicator.style.opacity = '0';
                                                    // Remove after fade out
                                                    setTimeout(() => {
                                                        if (finalIndicator.parentNode) {
                                                            finalIndicator.parentNode.removeChild(finalIndicator);
                                                        }
                                                    }, 1000);
                                                }, 2000);
                                            }
                                        }
                                    }
                                    
                                    // Reset streaming content after completion
                                    messageTracking[conversationId]._streamContent = "";
                                    console.log(`Response complete for message ${messageId}`);
                                    
                                    // Automatically refresh context after final message
                                    if (document.getElementById('context-toggle').checked) {
                                        setTimeout(() => {
                                            getContextPreview();
                                        }, 500);
                                    }
                                    break;
                                    
                                case 'tool':
                                    // Handle tool execution
                                    const toolName = data.metadata?.tool_name || "unknown";
                                    const toolContent = content || `Executing tool: ${toolName}...`;
                                    
                                    // Log tool usage
                                    addMessage('system', `Using tool: ${toolName}`);
                                    
                                    // Update or create tool message
                                    updateOrCreateMessage(
                                        conversationId,
                                        messageId,
                                        'tool',
                                        toolContent,
                                        inReplyTo
                                    );
                                    
                                    // Reset streaming content buffer
                                    messageTracking[conversationId]._streamContent = "";
                                    break;
                                    
                                case 'tool_result':
                                    // Handle tool result
                                    const toolResult = data.metadata?.result || "";
                                    const toolMessageId = data.metadata?.tool_message_id;
                                    let resultText = toolResult;
                                    if (typeof resultText === 'object') {
                                        resultText = JSON.stringify(resultText, null, 2);
                                    }
                                    
                                    // Format actual content or use provided content
                                    const formattedToolResult = content || `Tool result: ${resultText}`;
                                    
                                    // Update or create tool result message
                                    updateOrCreateMessage(
                                        conversationId,
                                        messageId,
                                        'tool',
                                        formattedToolResult,
                                        toolMessageId // Link to the tool call message
                                    );
                                    break;
                                    
                                default:
                                    console.log(`Unknown message type: ${messageType}`);
                            }
                            return;
                        }
                        
                        // Legacy event handling for backward compatibility
                        switch (data.type) {
                            case 'input':
                                // Handle input confirmation from server (legacy format)
                                if (data.data && conversationId) {
                                    // Use server-provided message ID if available, or generate one
                                    const messageId = data.data.message_id || `user-${Date.now()}`;
                                    
                                    // Find existing message with matching content
                                    const existingMessageElement = findMatchingUserMessage(data.data.content);
                                    
                                    if (existingMessageElement) {
                                        // Update with server ID instead of creating a new one
                                        console.log('Legacy: Found existing message, updating with server ID');
                                        existingMessageElement.id = `msg-${messageId}`;
                                        existingMessageElement.dataset.messageId = messageId;
                                        
                                        // Update tracking
                                        if (existingMessageElement.dataset.tempId) {
                                            const tempId = existingMessageElement.dataset.tempId;
                                            if (messageTracking[conversationId][tempId]) {
                                                delete messageTracking[conversationId][tempId];
                                            }
                                        }
                                        
                                        // Add to tracking with server ID
                                        messageTracking[conversationId][messageId] = {
                                            type: 'user',
                                            content: data.data.content,
                                            timestamp: data.timestamp || new Date().toISOString()
                                        };
                                        
                                        // Update active message tracking
                                        activeMessages[conversationId].user = messageId;
                                    } else {
                                        // Create new message (rare case)
                                        updateOrCreateMessage(
                                            conversationId, 
                                            messageId, 
                                            'user', 
                                            data.data.content
                                        );
                                    }
                                }
                                break;
                                
                            case 'response':
                                // Handle final response (legacy format)
                                if (data.data && conversationId) {
                                    const messageId = data.data.message_id;
                                    const inReplyTo = data.data.in_reply_to;
                                    const content = data.data.content;
                                    
                                    if (messageId) {
                                        updateOrCreateMessage(
                                            conversationId,
                                            messageId,
                                            'assistant',
                                            content,
                                            inReplyTo
                                        );
                                        
                                        messageTracking[conversationId]._streamContent = "";
                                        
                                        // Refresh context
                                        if (document.getElementById('context-toggle').checked) {
                                            setTimeout(() => {
                                                getContextPreview();
                                            }, 500);
                                        }
                                    }
                                }
                                break;
                                
                            case 'response_chunk':
                            case 'response_complete':
                            case 'tool_execution':
                            case 'tool_result':
                                console.log(`Received legacy event type: ${data.type}`);
                                // Process legacy events similarly to their unified counterparts
                                // (Specific handlers omitted for brevity since we're transitioning away from these)
                                break;
                                
                            default:
                                console.log('Unknown event type:', data.type);
                                addMessage('system', `Received event of type: ${data.type}`);
                        }
                    } catch (error) {
                        console.error('Error processing SSE event:', error);
                        addMessage('system', `Error processing event: ${error.message}`);
                    }
                });
                
                source.addEventListener('error', function(error) {
                    console.error('SSE error:', error);
                    addMessage('system', 'SSE error occurred. Check console for details.');
                });
                
                addMessage('system', 'SSE connection established and running');
            } catch (error) {
                addMessage('system', `SSE connection error: ${error.message}`);
                console.error('SSE connection error:', error);
                
                // Clean up controller on error
                sseController = null;
            }
        }

        // Stop SSE connection
        function stopCommunication() {
            // Close EventSource if active
            if (window.eventSource) {
                window.eventSource.close();
                window.eventSource = null;
                addMessage('system', 'SSE connection closed');
                
                // Keep message tracking data but reset active messages
                // This allows us to continue displaying messages but not update them
                if (selectedConversationId && activeMessages[selectedConversationId]) {
                    // Reset active messages for current conversation only
                    activeMessages[selectedConversationId] = {
                        user: null,
                        response: null,
                        tool: null
                    };
                    
                    // Reset streaming content
                    if (messageTracking[selectedConversationId]) {
                        messageTracking[selectedConversationId]._streamContent = "";
                    }
                }
            }
        }

        // Clear messages
        function clearMessages() {
            document.getElementById('messages').innerHTML = '';
            
            // Reset message tracking for current conversation
            if (selectedConversationId) {
                // Clear the message tracking for this conversation but keep the structure
                messageTracking[selectedConversationId] = {
                    _streamContent: ""
                };
                
                // Reset active message tracking
                activeMessages[selectedConversationId] = {
                    user: null,
                    response: null,
                    tool: null
                };
                
                console.log("Cleared messages and reset tracking for conversation:", selectedConversationId);
            }
        }

        // Get context from Cognition Service
        async function getContext() {
            if (!token || !user) {
                addMessage('system', 'Not authenticated. Please login first.');
                return;
            }
            
            const query = document.getElementById('context-query').value.trim();
            const limit = parseInt(document.getElementById('context-limit').value);
            const recencyWeight = parseFloat(document.getElementById('recency-weight').value);
            
            try {
                const response = await fetch(`${API_URL}/cognition/context`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        query: query || null,
                        limit: limit,
                        recency_weight: recencyWeight
                    })
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Failed to get context: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                lastContextResult = data.data;
                
                // Display results
                const resultsDiv = document.getElementById('context-results');
                resultsDiv.innerHTML = '';
                
                if (data.data.context && data.data.context.length > 0) {
                    // Add summary
                    const summary = document.createElement('div');
                    summary.innerHTML = `<strong>Found ${data.data.count} context items</strong>${data.data.query ? ` for query "${data.data.query}"` : ''}<br><br>`;
                    resultsDiv.appendChild(summary);
                    
                    // Add each context item
                    data.data.context.forEach((item, index) => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'context-message';
                        itemDiv.innerHTML = `
                            <strong>${index + 1}. ${formatTimestamp(item.timestamp)}</strong>
                            <div>${item.content}</div>
                            <button class="toggle-button" onclick="toggleItem('context-item-${index}')">Show details</button>
                            <div id="context-item-${index}" class="expandable">
                                <pre>${JSON.stringify(item, null, 2)}</pre>
                            </div>
                        `;
                        resultsDiv.appendChild(itemDiv);
                    });
                } else {
                    resultsDiv.textContent = 'No context items found';
                }
                
                // Add to chat log as well
                addMessage('context', `Retrieved ${data.data.count} context items${data.data.query ? ` for query "${data.data.query}"` : ''}`);
                
            } catch (error) {
                document.getElementById('context-results').textContent = `Error: ${error.message}`;
                console.error('Get context error:', error);
            }
        }

        // Analyze conversation
        async function analyzeConversation() {
            if (!token) {
                addMessage('system', 'Not authenticated. Please login first.');
                return;
            }
            
            if (!selectedConversationId) {
                addMessage('system', 'No conversation selected. Please select a conversation first.');
                return;
            }
            
            const analysisType = document.getElementById('analysis-type').value;
            
            try {
                const response = await fetch(`${API_URL}/v1/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        conversation_id: selectedConversationId,
                        analysis_type: analysisType
                    })
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Failed to analyze conversation: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Display results
                const resultsDiv = document.getElementById('analysis-results');
                resultsDiv.innerHTML = '';
                
                if (data.data) {
                    // Format based on analysis type
                    const analysisDiv = document.createElement('div');
                    analysisDiv.className = 'analysis-message';
                    
                    let analysisContent = '';
                    
                    switch (data.data.type) {
                        case 'summary':
                            const results = data.data.results;
                            analysisContent = `
                                <strong>Conversation Summary</strong><br>
                                Message Count: ${results.message_count}<br>
                                Participants: ${results.participants}<br>
                                Duration: ${formatSeconds(results.duration_seconds)}<br>
                            `;
                            break;
                        case 'topics':
                            const keywords = data.data.results.keywords || [];
                            analysisContent = `
                                <strong>Topic Analysis</strong><br>
                                Total Words: ${data.data.results.word_count}<br>
                                Top Keywords:<br>
                                <ul>
                                    ${keywords.map(k => `<li>${k.word} (${k.count})</li>`).join('')}
                                </ul>
                            `;
                            break;
                        case 'sentiment':
                            const sentiment = data.data.results;
                            const sentimentScore = parseFloat(sentiment.sentiment_score).toFixed(2);
                            const sentimentLabel = sentimentScore > 0.2 ? 'Positive' : 
                                                   sentimentScore < -0.2 ? 'Negative' : 'Neutral';
                            analysisContent = `
                                <strong>Sentiment Analysis</strong><br>
                                Overall Sentiment: ${sentimentLabel} (${sentimentScore})<br>
                                Positive Words: ${sentiment.positive_count}<br>
                                Negative Words: ${sentiment.negative_count}<br>
                            `;
                            break;
                        default:
                            analysisContent = `<pre>${JSON.stringify(data.data, null, 2)}</pre>`;
                    }
                    
                    analysisDiv.innerHTML = analysisContent;
                    resultsDiv.appendChild(analysisDiv);
                    
                    // Add raw data toggle
                    const rawToggle = document.createElement('div');
                    rawToggle.innerHTML = `
                        <button class="toggle-button" onclick="toggleItem('analysis-raw')">Show raw data</button>
                        <div id="analysis-raw" class="expandable">
                            <pre>${JSON.stringify(data.data, null, 2)}</pre>
                        </div>
                    `;
                    resultsDiv.appendChild(rawToggle);
                    
                    // Add to chat log
                    addMessage('analysis', `Analyzed conversation (${analysisType}): ${summarizeAnalysis(data.data)}`);
                    
                } else {
                    resultsDiv.textContent = 'No analysis results returned';
                }
                
            } catch (error) {
                document.getElementById('analysis-results').textContent = `Error: ${error.message}`;
                console.error('Analyze conversation error:', error);
            }
        }

        // Summarize analysis for chat log
        function summarizeAnalysis(data) {
            if (!data || !data.type) return 'No results';
            
            switch (data.type) {
                case 'summary':
                    return `${data.results.message_count} messages, ${data.results.participants} participants`;
                case 'topics':
                    const topKeywords = (data.results.keywords || []).slice(0, 3).map(k => k.word).join(', ');
                    return `Top keywords: ${topKeywords}`;
                case 'sentiment':
                    const score = parseFloat(data.results.sentiment_score).toFixed(2);
                    return `Sentiment score: ${score} (${score > 0.2 ? 'Positive' : score < -0.2 ? 'Negative' : 'Neutral'})`;
                default:
                    return 'Analysis completed';
            }
        }

        // Search user history
        async function searchHistory() {
            if (!token || !user) {
                addMessage('system', 'Not authenticated. Please login first.');
                return;
            }
            
            const query = document.getElementById('search-query').value.trim();
            
            if (!query) {
                addMessage('system', 'Please enter a search query.');
                return;
            }
            
            const limit = parseInt(document.getElementById('search-limit').value);
            const includeConversations = document.getElementById('include-conversations').checked;
            
            try {
                const response = await fetch(`${API_URL}/v1/search`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        query: query,
                        limit: limit,
                        include_conversations: includeConversations
                    })
                });
                
                lastApiResponse = await response.clone().json();
                updateLastResponse();
                
                if (!response.ok) {
                    throw new Error(`Failed to search history: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Display results
                const resultsDiv = document.getElementById('search-results');
                resultsDiv.innerHTML = '';
                
                if (data.data.results && data.data.results.length > 0) {
                    // Add summary
                    const summary = document.createElement('div');
                    summary.innerHTML = `<strong>Found ${data.data.count} results for "${data.data.query}"</strong><br><br>`;
                    resultsDiv.appendChild(summary);
                    
                    // Add each result
                    data.data.results.forEach((item, index) => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'search-message';
                        
                        let conversationInfo = '';
                        if (item._conversation_data) {
                            conversationInfo = `
                                <div>
                                    <small>From a conversation with ${item._conversation_data.participants} participants, 
                                    ${item._conversation_data.message_count} messages</small>
                                </div>
                            `;
                        }
                        
                        itemDiv.innerHTML = `
                            <strong>${index + 1}. ${formatTimestamp(item.timestamp)}</strong>
                            <div>${item.content}</div>
                            ${conversationInfo}
                            <button class="toggle-button" onclick="toggleItem('search-item-${index}')">Show details</button>
                            <div id="search-item-${index}" class="expandable">
                                <pre>${JSON.stringify(item, null, 2)}</pre>
                            </div>
                        `;
                        resultsDiv.appendChild(itemDiv);
                    });
                } else {
                    resultsDiv.textContent = `No results found for "${query}"`;
                }
                
                // Add to chat log
                addMessage('search', `Found ${data.data.count} results for "${query}"`);
                
            } catch (error) {
                document.getElementById('search-results').textContent = `Error: ${error.message}`;
                console.error('Search history error:', error);
            }
        }

        // Update last response in debug panel
        function updateLastResponse() {
            const lastResponseJson = document.getElementById('last-response-json');
            if (lastApiResponse) {
                lastResponseJson.textContent = JSON.stringify(lastApiResponse, null, 2);
            }
        }

        // Add message to the messages container
        function addMessage(type, content) {
            const messagesContainer = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            // Format message based on type
            if (type === 'input') {
                messageDiv.textContent = `You: ${content}`;
            } else if (type === 'output') {
                messageDiv.textContent = `Server: ${content}`;
            } else if (type === 'context') {
                messageDiv.textContent = `Context: ${content}`;
            } else if (type === 'analysis') {
                messageDiv.textContent = `Analysis: ${content}`;
            } else if (type === 'search') {
                messageDiv.textContent = `Search: ${content}`;
            } else { // system
                messageDiv.textContent = `System: ${content}`;
            }
            
            // Add message to container
            messagesContainer.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Add or update a message for a specific conversation
        function updateOrCreateMessage(conversationId, messageId, type, content, inReplyTo = null, source = null) {
            // Store in tracking
            if (!messageTracking[conversationId]) {
                messageTracking[conversationId] = {};
            }
            
            // Initialize active messages tracking if not present
            if (!activeMessages[conversationId]) {
                activeMessages[conversationId] = {
                    user: null,
                    response: null,
                    tool: null
                };
            }
            
            // Track active message ID by type
            if (type === 'user') {
                activeMessages[conversationId].user = messageId;
            } else if (type === 'assistant') {
                activeMessages[conversationId].response = messageId;
            } else if (type === 'tool') {
                activeMessages[conversationId].tool = messageId;
            }
            
            // Default source information if not provided
            if (!source) {
                if (type === 'user') {
                    source = {
                        id: user?.user_id || 'unknown-user',
                        name: 'You',
                        role: 'user'
                    };
                } else if (type === 'assistant') {
                    source = {
                        id: 'cortex-core',
                        name: 'Cortex',
                        role: 'assistant'
                    };
                } else if (type === 'tool') {
                    source = {
                        id: 'tool',
                        name: 'Tool',
                        role: 'tool'
                    };
                } else {
                    source = {
                        id: type,
                        name: type.charAt(0).toUpperCase() + type.slice(1),
                        role: 'system'
                    };
                }
            }
            
            // Determine display name based on source and current user
            let displayName;
            if (type === 'user' && source.id === user?.user_id) {
                displayName = 'You';
            } else {
                displayName = source.name;
            }
            
            // Update or create the message data in tracking
            const updatingExisting = !!messageTracking[conversationId][messageId];
            messageTracking[conversationId][messageId] = {
                type: type,
                content: content,
                timestamp: new Date().toISOString(),
                inReplyTo: inReplyTo,
                sender: source
            };
            
            // Update UI
            let messageDiv = document.getElementById(`msg-${messageId}`);
            const messagesContainer = document.getElementById('messages');
            
            if (!messageDiv) {
                // Create new element if it doesn't exist
                messageDiv = document.createElement('div');
                messageDiv.id = `msg-${messageId}`;
                messageDiv.dataset.messageId = messageId;
                messageDiv.dataset.type = type;
                messageDiv.dataset.conversationId = conversationId;
                messageDiv.dataset.senderId = source.id;
                messageDiv.dataset.senderName = source.name;
                messageDiv.dataset.senderRole = source.role;
                
                if (inReplyTo) {
                    messageDiv.dataset.inReplyTo = inReplyTo;
                }
                
                // Set class based on type
                if (type === 'user') {
                    messageDiv.className = 'message input-message';
                    messageDiv.textContent = `${displayName}: ${content}`;
                } else if (type === 'assistant') {
                    messageDiv.className = 'message output-message';
                    messageDiv.textContent = `${displayName}: ${content}`;
                } else if (type === 'tool') {
                    messageDiv.className = 'message system-message';
                    messageDiv.textContent = `${displayName}: ${content}`;
                } else {
                    messageDiv.className = 'message system-message';
                    messageDiv.textContent = `${displayName}: ${content}`;
                }
                
                // Add to container
                messagesContainer.appendChild(messageDiv);
                console.log(`Created new message with ID: ${messageId}, type: ${type}, source: ${source.name}`);
            } else {
                // Update existing element
                if (type === 'user') {
                    messageDiv.textContent = `${displayName}: ${content}`;
                } else if (type === 'assistant') {
                    messageDiv.textContent = `${displayName}: ${content}`;
                } else if (type === 'tool') {
                    messageDiv.textContent = `${displayName}: ${content}`;
                } else {
                    messageDiv.textContent = `${displayName}: ${content}`;
                }
                
                // If inReplyTo was provided, update that attribute
                if (inReplyTo && !messageDiv.dataset.inReplyTo) {
                    messageDiv.dataset.inReplyTo = inReplyTo;
                }
                
                // Update sender attributes
                messageDiv.dataset.senderId = source.id;
                messageDiv.dataset.senderName = source.name;
                messageDiv.dataset.senderRole = source.role;
                
                console.log(`Updated existing message with ID: ${messageId}, type: ${type}, source: ${source.name}`);
            }
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            return messageId;
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            if (!timestamp) return 'Unknown time';
            
            try {
                const date = new Date(timestamp);
                return date.toLocaleString();
            } catch (e) {
                return timestamp;
            }
        }

        // Format seconds to time string
        function formatSeconds(seconds) {
            if (!seconds) return '0s';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            
            let result = '';
            if (hours > 0) result += `${hours}h `;
            if (minutes > 0) result += `${minutes}m `;
            if (remainingSeconds > 0 || result === '') result += `${remainingSeconds}s`;
            
            return result.trim();
        }

        // Toggle expandable item
        window.toggleItem = function(id) {
            const element = document.getElementById(id);
            if (element.style.display === 'block') {
                element.style.display = 'none';
            } else {
                element.style.display = 'block';
            }
        }
    </script>
</body>
</html>